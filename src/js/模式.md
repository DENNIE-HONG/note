
# 模式
## 1 单体模式
只实例化一次
### 惰性实例化
如果单体已经实例化，返回现有实例
惰性加载单体：
```js
MyNamespace.singleton = function () {
  var uniqueInstance;
  function constructor () {
    ...
  }
  return {
    getInstance: function () {
      if (!uniqueInstance) {
        uniqueInstance = constructor();
      }
      return uniqueInstance;
    }
  }
}
// 调用
MyNamespace.singleton.getInstance().publickMethod);
```
## 2 工厂模式
抽象父类，在子类中创建工作方法。类型只在运行时确定的场景下更适合。  
举例xhr工厂
```js
var SimpleHander = function() {};
SimpleHandle.prototype = {
  request: function(method, url, callback, postVars) {
    var xhr = this.createXhrObject();
    xhr.onreadyStatechange = function () {
      if (xhr.readyState !== 4) {
        return;
      }
      xhr.status === 200 ? callback.success(xhr.responseText, xhr.responseXML) : callback.failure(xhr.status);
    }
    xhr.open(method, url, true);
    if (method !== 'POST') {
      postVars = null;
    }
    xhr.send(postVars);
  },
  // 工厂方法
  createXhrObject: function() {
    // 兼容不同的浏览器
    var method = [
      function() {return new XMLHttpRequest();}
      function() { return new ActiveXObject('');}
      function() { return new ActiveXObject('Microsoft');}
    ];
    for (var i = 0; i < method.length; i++) {
      try {
        // 方法首次执行时被调用一次
        method[i]();
      } catch (e) {
        continue;
      }
      // 此后只针对当前浏览器，复用能用的xhr
      this.createXhrObject = method[i];
      return method[i];
      
    }
    throw new Error('SimpleHandle: could not create XHR')
  }
};

// 调用
var myHandle = new SimpleHandler();
var callback = {
  success: function(responseText) {
    alert(responseText);
  },
  failure: function(stateCode) {
    alert('error');
  }
}
myHandler.request('GET', 'script.php', callback);
```
