
# 模式
找出程序中变化的地方，并将变化封装起来
## 1 单体模式
只实例化一次
### 惰性实例化
如果单体已经实例化，返回现有实例
惰性加载单体：
```js
MyNamespace.singleton = function () {
  var uniqueInstance;
  function constructor () {
    ...
  }
  return {
    getInstance: function () {
      if (!uniqueInstance) {
        uniqueInstance = constructor();
      }
      return uniqueInstance;
    }
  }
}
// 调用
MyNamespace.singleton.getInstance().publickMethod);
```
## 2 工厂模式
抽象父类，在子类中创建工作方法。类型只在运行时确定的场景下更适合。  
举例xhr工厂
```js
var SimpleHander = function() {};
SimpleHandle.prototype = {
  request: function(method, url, callback, postVars) {
    var xhr = this.createXhrObject();
    xhr.onreadyStatechange = function () {
      if (xhr.readyState !== 4) {
        return;
      }
      xhr.status === 200 ? callback.success(xhr.responseText, xhr.responseXML) : callback.failure(xhr.status);
    }
    xhr.open(method, url, true);
    if (method !== 'POST') {
      postVars = null;
    }
    xhr.send(postVars);
  },
  // 工厂方法
  createXhrObject: function() {
    // 兼容不同的浏览器
    var method = [
      function() {return new XMLHttpRequest();}
      function() { return new ActiveXObject('');}
      function() { return new ActiveXObject('Microsoft');}
    ];
    for (var i = 0; i < method.length; i++) {
      try {
        // 方法首次执行时被调用一次
        method[i]();
      } catch (e) {
        continue;
      }
      // 此后只针对当前浏览器，复用能用的xhr
      this.createXhrObject = method[i];
      return method[i];
      
    }
    throw new Error('SimpleHandle: could not create XHR')
  }
};

// 调用
var myHandle = new SimpleHandler();
var callback = {
  success: function(responseText) {
    alert(responseText);
  },
  failure: function(stateCode) {
    alert('error');
  }
}
myHandler.request('GET', 'script.php', callback);
```

## 3 组合模式
例如表单验证，表单的内容和数目是完全未知的，因用户而异
## 4 门面模式
简化类的接口，例如：各种JS库件
## 5 适配器模式
协调两个不同的接口，适用于客户系统期待的接口与现有API提供的接口不兼容的场合。

## 6 装饰者模式
可为对象增加新功能，所实现的每一个方法所做的只是在其组件上调用同名方法。  例如：
```js
getPrice: function() {
  return this.bicycle.getPrice() + 15;
}
```
如果为类增添特性需要派生大量子类，可以考虑用装饰者模式。就是会增加架构的复杂程度。

## 7 享元模式
用于减少应用程序所需对象数量，内部划分为内部数据和外部数据。例如：web日历需要为每一年创建365个对象。可以把天对象转化为享元对象。  
例如：工具提示，转化为享元，只需生成一个DOM元素，减少了对象内部保存的数据。而不用担心冒出了几千个实例。

## 8 命令模式
用来对方法调用进行参数化处理和传递
命令对象：执行操作(execute or run)
```js
function makeStart(adObject) {
  return function() {
    adObjact.start();
  };
}

function makeStop(adObject) {
  return function() {
    adObject.stop();
  };
}

var startCommand = makeStart(ads[0]);
var stopCommand = makeStop(ads[0]);
startCommand();
stopCommand();

```

## 9 职责链模式
事件委托
