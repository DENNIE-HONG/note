## 函数
### new 操作符具体干了什么事情？
1. 创建了一个空对象 var obj = new Object();
2. 设置原型链 obj._proto = Func.prototype;
3. 让Func中的this指向obj,并执行Func函数体；
4. 判断Func返回值类型；
```js
function new (func) {
  let o = object.create(func.prototype);
  let k = func.call(o);
  return typeof k === 'object' ? k: o;
}
```

### 闭包
有权访问另一个函数作用域中的变量的函数。

## 数字
### 浮点数运算问题
例如：0.1 + 0.2 === 0.3 // false
Number.EPSILON表示浮点运算舍入操作的安全误差范围。
```js
function withinMarginOfError(left, right) {
  return Math.abs(left - right) < Number.EPSILON;
}

withinMarginOfError(0.1 + 0.2, 0.3); // true
```

## 对象
即使在函数内部修改参数的值，原始引用保持未变.局部对象立即被销毁。
```js
function setName(obj) {
  obj.name = "Nicholas";
  obj = new Object();
  obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); // Nicholas
```

## Event Loop
js在执行中产生执行环境，会被顺序加入到执行栈中。遇到异步代码，会被挂起并加入到Task(有多种task)。队列中，一旦执行栈为空，Event Loop从Task队列中拿出需要执行的代码并放入执行栈中执行。  
任务源：  
* 微任务  
* 宏任务  

不同任务源会被分配到不同的task队列中。  
微任务：  
* process.nextTick  
* promise  
* Object.observe
* MutationObserver  

宏任务：  
* script
* setTimeout 
* setInterval
* setImmediate
* I/O
* UI rendering

Event Loop顺序:
1. 执行同步代码，这属于宏任务；
2. 执行栈为空，查询是否有微任务需要执行
3. 执行所有微任务
4. 必要的话渲染UI
5. 下一轮Event Loop, 执行宏任务中的异步代码。


## 模块化
例如有3个模块，a引用了b、c，a模块打印了‘aaa’，c模块打印了‘cccc’
### 1. commonjs
用module.exports 定义当前模块对外输出接口，用require加载模块，同步方式加载模块。  
执行:
```js
加载了a；
输出“aaa”
加载了b；
加载了c；
输出“ccc”
```
### 2. AMD和require.js （依赖前置）
用define()定义模块，require()加载模块，有依赖模块放在[]中作为第一参数
```js
define(['underscore'], function(_) {

});
require(['jquery', 'math'], function($, math) {

});

```
采用异步加载，模块加载不影响后续语句，等加载完才运行回调函数。  
执行：
```js
加载了a、加载了b、加载模块c
才开始输出“aaa”
```
### 3. CMD和sea.js
推崇依赖就近、延迟执行
```js
defind(function(require, exports, module) {
  var a = require('a');
  a.doSomething();
})
```
require时才去加载模块，加载完再接着执行。  
执行：和commonjs一样
```js
加载了a模块
输出“aaa”
加载了模块b
加载了模块c
输出“ccc”
```
### 4. es6 Module：export和import
import编译时就引入模块代码，而不是运行时加载，无法实现条件加载。 
执行：和AMD一样
```js
加载了a模块；
加载了b模块；
加载了c模块；
输出“aaa”
输出“ccc”
```
### 差异
1. commonjs输出是拷贝，es6输出的是绑定
2. commonjs模块是运行时加载，es6是编译时输出接口；
