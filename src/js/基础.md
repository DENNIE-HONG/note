## 函数
### new 操作符具体干了什么事情？
1. 创建了一个空对象 var obj = new Object();
2. 设置原型链 obj._proto = Func.prototype;
3. 让Func中的this指向obj,并执行Func函数体；
4. 判断Func返回值类型；
```js
function new (func) {
  let o = object.create(func.prototype);
  let k = func.call(o);
  return typeof k === 'object' ? k: o;
}
```

### 闭包
有权访问另一个函数作用域中的变量的函数。


## 对象
即使在函数内部修改参数的值，原始引用保持未变.局部对象立即被销毁。
```js
function setName(obj) {
  obj.name = "Nicholas";
  obj = new Object();
  obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); // Nicholas
```

## Event Loop
js在执行中产生执行环境，会被顺序加入到执行栈中。遇到异步代码，会被挂起并加入到Task(有多种task)。队列中，一旦执行栈为空，Event Loop从Task队列中拿出需要执行的代码并放入执行栈中执行。  
任务源：  
* 微任务  
* 宏任务  

不同任务源会被分配到不同的task队列中。  
微任务：  
* process.nextTick  
* promise  
* Object.observe
* MutationObserver  

宏任务：  
* script
* setTimeout 
* setInterval
* setImmediate
* I/O
* UI rendering

Event Loop顺序:
1. 执行同步代码，这属于宏任务；
2. 执行栈为空，查询是否有微任务需要执行
3. 执行所有微任务
4. 必要的话渲染UI
5. 下一轮Event Loop, 执行宏任务中的异步代码。


## bind的模拟实现？
bind()方法会创建一个新函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this。之后的参数会在传递实参前传入作为它的参数。
```js
Function.prototype.bind = function(context) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var bindArgs = Array.prototype.slice.call(arguments);
    self.apply(context, args.concat(bindArgs));
  }
}
```
问题：  
一个绑定函数也能使用new 操作符创建对象，这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给函数。  
bind改进：
```js
Function.prototype.bind = function(context) {
  if (typeof this !== 'function') {
    throw Error('调用不了');
  }
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var fNop = function () {};
  var fbound = function () {
    // 当作构造函数，this指向实例，self指向
    // 绑定函数，当普通函数，this指向window
    self.apply(this.instanceof self ? this: context, args.concat(Array.prototype.slice.call(arguments)));
  }
  fNop.prototype = this.prototype;
  // 修改fbound.prototype时候，不想修改绑定函数
  //的prototype
  fbound.prototype = new fNop();
  return fbound;
}
```

## 继承
以下3种继承方法与优缺点？
```js
function Shape() {}
function Rect() {}
```
### 方法1
```js
Rect.prototype = new Shape();
```
优点：
* 正确设置原型链实现继承；
* 父类实例属性得到继承，原型链查找效率高；  

缺点：
* 父类实例属性为**引用类型**时候，不恰当修改会导致所有子类修改；
* 无法确定构造函数需要的合理参数；

### 方法2
```js
Rect.prototype = Shape.prototype;
```
缺点：修改子类原型，添加方法会修改父类
### 方法3
```js
Rect.prototype = Object.create(Shape.prototype);
Rect.prototype.area = function() {
  // do something
}
```
避免了1.2中的缺点