## 1. 函数
### new 操作符具体干了什么事情？
1. 创建了一个空对象 var obj = new Object();
2. 设置原型链 obj._proto = Func.prototype;
3. 让Func中的this指向obj,并执行Func函数体；
4. 判断Func返回值类型；
```js
function new (func) {
  let o = object.create(func.prototype);
  let k = func.call(o);
  return typeof k === 'object' ? k: o;
}
```

### bind的模拟实现？
bind()方法会创建一个新函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this。之后的参数会在传递实参前传入作为它的参数。
```js
Function.prototype.bind = function(context) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var bindArgs = Array.prototype.slice.call(arguments);
    self.apply(context, args.concat(bindArgs));
  }
}
```
问题：  
一个绑定函数也能使用new 操作符创建对象，这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给函数。  
bind改进：
```js
Function.prototype.bind = function(context) {
  if (typeof this !== 'function') {
    throw Error('调用不了');
  }
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var fNop = function () {};
  var fbound = function () {
    // 当作构造函数，this指向实例，self指向
    // 绑定函数，当普通函数，this指向window
    self.apply(this.instanceof self ? this: context, args.concat(Array.prototype.slice.call(arguments)));
  }
  fNop.prototype = this.prototype;
  // 修改fbound.prototype时候，不想修改绑定函数
  //的prototype
  fbound.prototype = new fNop();
  return fbound;
}
```

### 闭包
有权访问另一个函数作用域中的变量的函数。

### 函数参数
参数传递：  
参数是基本类型是按值传递，引用类型按共享传递

### 防抖debounce
原理：
一定在事件触发N秒后才执行，如果在一个事件触发的n秒内又触发了，以新的时间为准。等你触发完事件n秒内不再触发，才执行。   
例如：resize、scroll事件
```js
function debounce(fn, delay, immediate) {
  let timer = null;
  let result;
  return function() {
    const context = this;
    const args = arguments;
    if (timer) {
      clearTimeout(timer);
    }
    if (immediate) {
      // 如果已执行过，不再执行
      const doNow = !timer;
      timer = setTimeout((function() {
        timer = null;
      }, delay);
      if (doNow) {
        result = func.apply(context, args);
      }
    } else {
      timer = setTimeout(function() {
        func.apply(constext, args);
      }, delay);
    }
    return result;
  }
}
``` 


### 节流throttle
原理：持续触发事件，每隔一段时间，只执行一次事件。  
例如：输入框的联想
用setTimeout延迟，还没完成就忽略请求。
```js
// 定时器实现，
let throttle = function(func, delay) {
  let timer = null;
  return function() {
    const context = this;
    const args = arguments;
    if (!timer) {
      timer = setTimeout(function() {
        func.apply(context, args);
        timer = null;
      }, delay);
    }
  }
}
// 事件戳实现，事件会立即执行，停止触发后不再执行
let throttle = function(fn, delay) {
 let prev = 0;
 return function() {
   const context = this;
   const args = arguments;
   const now = Date.now();
   if (now - prev >= delay) {
     func.apply(context, args);
     prev = now;
   }
 }
};

```

### 偏函数
固定一个函数的一个或多个参数，将一个n元函数 => n-x元函数
```js
// 占位符
var _ = {};
function partial(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    var posiion = 0;
    var len = args.length;
    for (var i = 0; i < len; i++) {
      args[i] = args[i] === _? arguments[position++]: args[i];

    }
    while (position < arguments.length) {
      args.push(arguments[position++]);
    }
    return fn.apply(this, args);
  }
}

var subtract = function(a, b) {
  return b-a;
}
subForm20 = partial(subract, _, 20);
subForm(5); // 15
```
### 函数组合
原理：将多个函数组合一起，从右向左执行。  
作用：利用柯里化和compose实现pointfree。
不使用所要处理的值，只合成运算。上层运算不直接操作数据，通过底层去处理。

```js
function compose() {
  let args = arguments;
  const start = args.length - 1;
  return function() {
    let i = start;
    let result = args[start].apply(this, arguments);
    while(i--) {
      result = args[i].call(this, result);
    }
    return result;
  }
}
```

### 尾调用优化TCO
减少调用栈帧，引擎不用限制栈深度。
例子：递归
```js
function factoria(n) {
  function fact(n, res) {
    if (n < 2) {
      return res;
    }
    return fact(n-1, n * res);
  }
  return fact(n, 1);
}
```



## 2. 对象
即使在函数内部修改参数的值，原始引用保持未变.局部对象立即被销毁。
```js
function setName(obj) {
  obj.name = "Nicholas";
  obj = new Object();
  obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); // Nicholas
```






## 3. 继承
js中根对象是Object.prototype,每个对象都是从Object.prototype克隆来的。  
```js
var obj = new Object(); // 原型 => Object.prototype

```
以下3种继承方法与优缺点？
```js
function Shape() {}
function Rect() {}
```
### 方法1
```js
Rect.prototype = new Shape();
```
优点：
* 正确设置原型链实现继承；
* 父类实例属性得到继承，原型链查找效率高；  

缺点：
* 父类实例属性为**引用类型**时候，不恰当修改会导致所有子类修改；
* 无法确定构造函数需要的合理参数；

### 方法2
```js
Rect.prototype = Shape.prototype;
```
缺点：修改子类原型，添加方法会修改父类
### 方法3
```js
Rect.prototype = Object.create(Shape.prototype);
Rect.prototype.area = function() {
  // do something
}
```
避免了1.2中的缺点

### 为什么用Object.create(null)来创建对象？而不用{}
因为{}会继承Object原型链上所有方法。而原型是可以修改的，例如别的库or开发者修改了Object原型，{}也会继承修改后的方法。

## 4. this
### 用ECMAScript规范解读this  （较难）
前提：什么是Reference?  
* 用来解释诸如delete/typeof 以及赋值等操作行为的。Reference Type本身是一个三个值的组合(base,name,strict)  

MemberExpression?    
一般是()的左边

1. 计算MemberExpression赋给ref
2. 判断ref是不是Reference?  
    * 是，this = GetBase(ref);  
    * 是，base value是Environment Record, this => undefiend  
    * 不是，this => undefined

栗子
```js
var value = 1;
var foo = {
  value: 2,
  bar: function() {
    return this.value;
  }
}
```
1. console.log(foo.bar()): 
```js
ref = MemberExpression() = foo.bar
// 是Reference
Reference = {
  base: foo,
  name: 'bar',
  strict: false
}
// this = GetBase(ref)
// this = foo
// 答案是2
```

2. console.log((foo.bar)())  
()并没有对MemberExpression计算，结果与上面一样

3. console.log((foo.bar = foo.bar)());  
赋值操作符=，返回不是Reference.
this = undefined, 答案是1
4. console.log((false || foo.bar)());  
逻辑与运算，不是Reference类型，this = undefined
5. console.log((foo.bar, foo.bar)());  
逗号运算符，返回不是Reference类型，this = undefined

### this绑定
显性、隐形、硬绑定、new绑定、默认绑定
绑定优先级：new绑定 > 硬绑定or显示 > 隐式 > 默认  
更安全的this： 调用时根本不在乎this指向谁时，可用
```js
const a = Objact.create(null);
foo.apply(a, [2, 3]);
```

## 5. 操作符
### 5.1 ~X
~X 等同于 -(x+1)
```js
~42; // -43
```
-1 是一个"哨位值"，indexOf(...)找不到字符串所在位置，返回-1.
例如：  
```js
const a = "Hello World";
if (a.indexOf("ol") === -1) {
  // 没有匹配到，抽象渗漏，暴露了底层实现细节
}

if (!~a.indexOf("ol")) {
  console.log("没有匹配到");
}
```

### 5.2 隐式转换
#### 5.2.1 隐式转换为布尔
* if ()
* for(..;...;...)
* while(...)和do...while(...)
* ?:
* ||和&&

#### 5.2.2 x == y
==：允许强制类型转换，会出很多意想不到的问题。  
##### 情况1：
1. x布尔，返回ToNumber(x) == y
2. y布尔，返回x == ToNumber(y)
哪个是布尔，先转为数字。
```js
const x = "42";
const y = true;
console.log(x == y); // false
```
**尽量不要使用 == true和 == false情况**
举个🌰：
```js
const a = "42";
if (a == true) {} // false
if (a === true){} // false
if (a) {} // true
if (!aa) {} // 更好！！！
if(Boolean(a)) {} // true

```

```js
false == 0; => 0 == 0; // true
false === ""; => 0 == "" ; => 0 == 0; // true
false == []; => false == ""; => 0 == ""; => 0 == 0; // true
```
——————————————————————————————————————————————————

##### 情况2：
1. x null，y = undefiend, true
2. x = undefiend, y = null, true
```js
let a = null;
let b;
console.log(a == b); // true
console.log(a == null); // true
console.log(b == null); // true

let a = doSomething(); // 返回null or undefiend
if (a == null) {} // true
```
————————————————————————————————————————————————————
##### 情况3：
x == y ? (对象 vs 数字or字符串)：哪个是对象，对象先转成**字符串**，再对比
```js
const a = "abc";
const b = Object(a);
console.log(a == b); // true
```

```js
const a = null;
const b = Object(a);
console.log(a == b); // false
```
————————————————————————————————————————————————————
##### 情况4：
1. x数字，y字符串，x == ToNumber(y);
2. x字符串，y数字，ToNumber(x) == y;
哪个是字符串，转为数字再对比；

```js
"0" == false; 转 "0" == 0; 转 0 == 0; // true,布尔先转数字
"" == []; 转 "" == ""; // true, 对象先转字符串
0 == []; 转 0 == ""; 转 0 == 0; // true
```
注意：**==“”、==0**
举个例子：
```js
function doSomething(a) {
  if (a == "") {...} // 改用a === ""
}
doSomething(0);
doSomething([]); // 都会执行
```

#### 5.2.3 a < b 关系比较
关系比较时候，先进行显式强制类型转换
举个例子：
```js
const a = { b: 42};
const b = {b: 43};
console.log(a < b); //false
console.log(a == b); // false
console.log(a > b); // false
console.log(a <= b); // true
console.log(a >= b); // true
a <= b;   转成  !(b < a); 得到 true
```

#### 5.2.4 x + y
坑来了：
```js
[] + {}; // ["object Object"]
{} + []; // 0
```
+字符串变数字
```js
[] + {}; 转 "" + "[object Object]"; => ["object Object"];
{} + []; 转 +[] ; => + "" => 0; // 空代码块，不作任何操作
```

## 5.3 ?:和 =
都是右关联的。
```js
a ? b : c ? d: e;    =>    a ? b : (c ? d: e);
```
```js
a = b = c = 42;  =>   a = (b = (c = 42));
```
