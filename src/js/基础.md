## 1. 函数
### new 操作符具体干了什么事情？
1. 创建了一个空对象 var obj = new Object();
2. 设置原型链 obj._proto = Func.prototype;
3. 让Func中的this指向obj,并执行Func函数体；
4. 判断Func返回值类型；
```js
function new (func) {
  let o = object.create(func.prototype);
  let k = func.call(o);
  return typeof k === 'object' ? k: o;
}
```

### bind的模拟实现？
bind()方法会创建一个新函数，当这个新函数被调用时，bind()的第一个参数将作为它运行时的this。之后的参数会在传递实参前传入作为它的参数。
```js
Function.prototype.bind = function(context) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    var bindArgs = Array.prototype.slice.call(arguments);
    self.apply(context, args.concat(bindArgs));
  }
}
```
问题：  
一个绑定函数也能使用new 操作符创建对象，这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给函数。  
bind改进：
```js
Function.prototype.bind = function(context) {
  if (typeof this !== 'function') {
    throw Error('调用不了');
  }
  var self = this;
  var args = Array.prototype.slice.call(arguments, 1);
  var fNop = function () {};
  var fbound = function () {
    // 当作构造函数，this指向实例，self指向
    // 绑定函数，当普通函数，this指向window
    self.apply(this.instanceof self ? this: context, args.concat(Array.prototype.slice.call(arguments)));
  }
  fNop.prototype = this.prototype;
  // 修改fbound.prototype时候，不想修改绑定函数
  //的prototype
  fbound.prototype = new fNop();
  return fbound;
}
```

### 闭包
有权访问另一个函数作用域中的变量的函数。

### 函数参数
参数传递：  
参数是基本类型是按值传递，引用类型按共享传递

### 防抖
原理：
一定在事件触发N秒后才执行，如果在一个事件触发的n秒内又触发了，以新的时间为准。等你触发完事件n秒内不再触发，才执行。

### 节流
原理：持续触发事件，每隔一段时间，只执行一次事件。

### 偏函数
固定一个函数的一个或多个参数，将一个n元函数 => n-x元函数
```js
// 占位符
var _ = {};
function partial(fn) {
  var args = [].slice.call(arguments, 1);
  return function() {
    var posiion = 0;
    var len = args.length;
    for (var i = 0; i < len; i++) {
      args[i] = args[i] === _? arguments[position++]: args[i];

    }
    while (position < arguments.length) {
      args.push(arguments[position++]);
    }
    return fn.apply(this, args);
  }
}

var subtract = function(a, b) {
  return b-a;
}
subForm20 = partial(subract, _, 20);
subForm(5); // 15
```
### 函数组合
原理：将多个函数组合一起，从右向左执行。  
作用：利用柯里化和compose实现pointfree。
不使用所要处理的值，只合成运算。上层运算不直接操作数据，通过底层去处理。

```js
function compose() {
  let args = arguments;
  const start = args.length - 1;
  return function() {
    let i = start;
    let result = args[start].apply(this, arguments);
    while(i--) {
      result = args[i].call(this, result);
    }
    return result;
  }
}
```



## 2. 对象
即使在函数内部修改参数的值，原始引用保持未变.局部对象立即被销毁。
```js
function setName(obj) {
  obj.name = "Nicholas";
  obj = new Object();
  obj.name = "Greg";
}
var person = new Object();
setName(person);
alert(person.name); // Nicholas
```






## 3. 继承
以下3种继承方法与优缺点？
```js
function Shape() {}
function Rect() {}
```
### 方法1
```js
Rect.prototype = new Shape();
```
优点：
* 正确设置原型链实现继承；
* 父类实例属性得到继承，原型链查找效率高；  

缺点：
* 父类实例属性为**引用类型**时候，不恰当修改会导致所有子类修改；
* 无法确定构造函数需要的合理参数；

### 方法2
```js
Rect.prototype = Shape.prototype;
```
缺点：修改子类原型，添加方法会修改父类
### 方法3
```js
Rect.prototype = Object.create(Shape.prototype);
Rect.prototype.area = function() {
  // do something
}
```
避免了1.2中的缺点

## 4. this
### 用ECMAScript规范解读this  （较难）
前提：什么是Reference?  
* 用来解释诸如delete/typeof 以及赋值等操作行为的。Reference Type本身是一个三个值的组合(base,name,strict)  

MemberExpression?    
一般是()的左边

1. 计算MemberExpression赋给ref
2. 判断ref是不是Reference?  
    * 是，this = GetBase(ref);  
    * 是，base value是Environment Record, this => undefiend  
    * 不是，this => undefined

栗子
```js
var value = 1;
var foo = {
  value: 2,
  bar: function() {
    return this.value;
  }
}
```
1. console.log(foo.bar()): 
```js
ref = MemberExpression() = foo.bar
// 是Reference
Reference = {
  base: foo,
  name: 'bar',
  strict: false
}
// this = GetBase(ref)
// this = foo
// 答案是2
```

2. console.log((foo.bar)())  
()并没有对MemberExpression计算，结果与上面一样

3. console.log((foo.bar = foo.bar)());  
赋值操作符=，返回不是Reference.
this = undefined, 答案是1
4. console.log((false || foo.bar)());  
逻辑与运算，不是Reference类型，this = undefined
5. console.log((foo.bar, foo.bar)());  
逗号运算符，返回不是Reference类型，this = undefined