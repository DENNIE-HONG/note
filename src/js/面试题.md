# 面试题锦集
## 字符串repeact实现?
1. 'ni'.repeact(3);
2. 
```js
String.prototype.repeact = function (n) {
  return Array(n+1).join(this);
}

```
3. 
```js
String.prototype.repeact = function(n) {
  return Array(n).fill(this).join('');
}
```

## 介绍模块化？
例如有3个模块，a引用了b、c，a模块打印了‘aaa’，c模块打印了‘cccc’
### 1. commonjs
用module.exports 定义当前模块对外输出接口，用require加载模块，同步方式加载模块。  
执行:
```js
加载了a；
输出“aaa”
加载了b；
加载了c；
输出“ccc”
```
### 2. AMD和require.js （依赖前置）
用define()定义模块，require()加载模块，有依赖模块放在[]中作为第一参数
```js
define(['underscore'], function(_) {

});
require(['jquery', 'math'], function($, math) {

});

```
采用异步加载，模块加载不影响后续语句，等加载完才运行回调函数。  
执行：
```js
加载了a、加载了b、加载模块c
才开始输出“aaa”
```
### 3. CMD和sea.js
推崇依赖就近、延迟执行
```js
defind(function(require, exports, module) {
  var a = require('a');
  a.doSomething();
})
```
require时才去加载模块，加载完再接着执行。  
执行：和commonjs一样
```js
加载了a模块
输出“aaa”
加载了模块b
加载了模块c
输出“ccc”
```
### 4. es6 Module：export和import
import编译时就引入模块代码，而不是运行时加载，无法实现条件加载。 
执行：和AMD一样
```js
加载了a模块；
加载了b模块；
加载了c模块；
输出“aaa”
输出“ccc”
```
### 差异
1. commonjs输出是拷贝，es6输出的是绑定
2. commonjs模块是运行时加载，es6是编译时输出接口；

## 实现一个深度克隆？
注意点：
* 复制函数
* 复制正则对象
* 抛弃对象的constructor,所有构造函数指向Object

```js
// 工具函数，对象类型判断
function isType (obj, type) {
  if (typeof obj !== 'Object') {
    return false;
  }
  const typeString = Object.prototype.toString().call(obj);
  let flag;
  switch (type) {
    case 'Array':
      flag = typeString === '[object Array]';
      break;
    case 'Date':
      flag = typeString === '[object Date]';
      break;
    case 'RegExp':
      flag = typeString === '[object RegExp]';
      break;
    default: 
      flag = false;
  }
  return flag;
} 

const getRegExp = (re) => {
  let flags = '';
  if (re.global) {
    flags += 'g';
  }
  if (re.ignoreCase) {
    flags += 'i';
  }
  if (re.multiline) {
    flags += 'm';
  }
  return flags;
}


function clone (parent) {
  const parents = [];
  const children = [];
  const _clone = (parent) => {
    if (parent === null) {
      return null;
    }
    if (typeof parent !== 'object') {
      return parent;
    }
    let child;
    let proto;
    if (isType(parent, 'Array')) {
      child = [];
    } else if (isType(parent, 'RegExp')) {
      child = new RegExp(parent.source, getRegExp(parent));
      if (parent.lastIndex) {
        child.lastIndex = parent.lastIndex;
      }
    } else if (isType(parent, 'Date')) {
      child = new Date(parent.getTime());
    } else {
      // 处理原型对象
      proto = Object.getPrototypeOf(parent);
      child = Object.create(proto);

    }
    // 处理循环引用
    const index = parents.indexOf(parent);
    if (index !== -1) {
      return children[index];
    }
    parents.push(parent);
    children.push(child);
    for (let i in parent) {
      child[i] = _clone(parent[i]);
    }
    return child;
  }

  return _clone(parent);

}
```

## 如何实现Event库(发布订阅模式)
```js
class EventEmeitter {
  constructor() {
    this._events = this._events || new Map();
    this._maxListeners = this._maxListeners || 10;
  }

  emit (type, ...args) {
    let handler;
    handler = this._events.get(type);
    if (Array.isArray(handler)) {
      for (let i = 0; i < handler.length; i++) {
        if (args.length > 0) {
          handler[i].apply(this, args);
        } else {
          handler[i].call(this);
        }
      }
    } else {
         if (args.length > 0) {
          handler[i].apply(this, args);
        } else {
          handler[i].call(this);
        }
    }
    return true;
  }

  addListener (type, fn) {
    const handler = this._events.get(type);
    if (!handller) {
      this._events.set(type, fn);
    } else if (handler && typeof handler === 'function') {
      this._events.set(type, [handler, fn])
    } else {
      handler.push(fn);
    }
  }

  removeListener(type, fn) {
    const handler = this._events.get(type);
    if (hander && typeof handler === 'function') {
      this._events.delete(type, fn);
    } else {
      let position;
      for (let i = 0; i < handler.length; i++) {
        if (hander[i] === fn) {
          position = i;
        } else {
          position = -1;
        }
      }
    }
    if (position !== -1) {
      handler.splice(position, 1);
      // 清除后只有一个函数，以函数形式保存
      if (handler.length === 1) {
        this._event.set(type, handler[0]);
      }
    } else {
      return this;
    }
  }
 }
```

## 前端注意哪些SEO?
1. 合理的title、description、keywords：搜索对这三项权重逐个减少
2. 语义化的HTML代码
3. 少用iframe：搜索引擎不会抓取iframe中的内容
4. 非装饰性图片必须加alt
5. 提高网站速度：网站速度是搜索引擎排序重要指标
6. 重要的内容不要用js输出


## 图片懒加载？
利用最新API: IntersectionObserver  
new IntersectionObserver(callback, options)

```js
// <img data-src="xxx">
function query(tag) {
  return Array.from(document.getElementsByTagName(tag));
}

const observer = new IntersectionObserver((changes) => {
  changes.forEach((change) => {
    // 可见比例
    if (change.intersectionRatio >0) {
      const img = change.target;
      img.src = img.dataset.src;
      // 不再监听
      observer.unobserve(img);
    }
  });
});
query('img').forEach((item) => observer.observe(item));
```


## display: none;与visibity:hidden；的区别？
1. display:none会让元素完全从渲染树中消失，渲染时候不占据任何空间。visibility: hidden不会让渲染树消失，占据空间，内容不可见。

2. display:none;非继承属性，修改子孙节点属性无法显示。visibility:hidden继承属性，通过设置可让子孙节点显示。

3. 修改常规流中元素display造成重排，修改visibility造成重绘；

4. 读屏器不读display:none内容，会读visibility内容。