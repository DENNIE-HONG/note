# promise/async/await
## 1. async的语法糖
异步函数内部同时利用了生成器和Promise
```js
async function example(a, b, c) {
  // 函数体
}
```

其实是
```js
function example (a, b, c) {
  return spawn(function*() {
    // 函数体
  });
}
```

```js
  function spawn(generator) {
    // 将所有代码包装在一个Promise中
    return new Promise((resolve, reject) => {
      const g = generator();
      // 运行第一步
      step(() => g.next());
      
      function runNext(nextFn) {
        try {
          // 继续执行生成器代码
          return nextFn();
          
        } catch (err) {
          // 以失败告终，拒绝当前Promise
          reject(err);
        }
      }
      function step(nextFn) {
        const next = runNext(nextFn);
        if (next.done) {
          resolve(next.value);
          return;
        }
        // 未结束，连缀返回的Promise并运行下一步
        Promise.resolve(next.value)
        .then((value) => step(() => g.next(value)), err => step(() => g.throw(err)));
      }
    })
  }
```
## 2. Promise的超时机制
利用Promise.race 
```js
function delayPromise(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

function timeoutPromise(promise, ms) {
  const timeout = delayPromise(ms).then(() => {
    throw New Error('operation timed out after' + ms + 'ms');
  });
  return Promise.race(promise, timeout);
}

// 使用
const taskPromise = new Promise((resolve) => {
  const delay = Math.random() * 2000;
  setTimeout(() => {
    resolve(delay + 'ms');
  }, delay);
});
timeoutPromise(taskPromise, 1000).then((value) => {
  console.log('规定时间内结束');
}).catch(() => {
  console.log('超时');
});
```

## 3. 实现一个Promise注意事项
1. 同步任务：利用setTimeout特性将resolve和reject具体执行放到then之后
2. 三种状态：then方法里对三种状态做判断
3. 支持链式操作：then方法里最后返回this
4. 支持串行异步任务：每个回调函数注册在对应的异步操作promise的onFulfilledCallback里。令then最后返回一个新promise




## 4. 实现Promise.finally?
```js
Promise.prototype.finally = function(callback) {
  let p = this.constructor;
  return this.then(
    value => p.resolve(callback()).then(() => value),
    reason => p.resolve(callback()).then(() => {
      throw reason;
    });
  )
}
```