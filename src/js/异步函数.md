# promise/async/await
## 1. async的语法糖
异步函数内部同时利用了生成器和Promise
```js
async function example(a, b, c) {
  // 函数体
}
```

其实是
```js
function example (a, b, c) {
  return spawn(function*() {
    // 函数体
  });
}
```

```js
  function spawn(generator) {
    // 将所有代码包装在一个Promise中
    return new Promise((resolve, reject) => {
      const g = generator();
      // 运行第一步
      step(() => g.next());
      
      function runNext(nextFn) {
        try {
          // 继续执行生成器代码
          return nextFn();
          
        } catch (err) {
          // 以失败告终，拒绝当前Promise
          reject(err);
        }
      }
      function step(nextFn) {
        const next = runNext(nextFn);
        if (next.done) {
          resolve(next.value);
          return;
        }
        // 未结束，连缀返回的Promise并运行下一步
        Promise.resolve(next.value)
        .then((value) => step(() => g.next(value)), err => step(() => g.throw(err)));
      }
    })
  }
```
## 2. Promise的超时机制
利用Promise.race 
```js
function delayPromise(ms) {
  return new Promise((resolve) => {
    setTimeout(resolve, ms);
  });
}

function timeoutPromise(promise, ms) {
  const timeout = delayPromise(ms).then(() => {
    throw New Error('operation timed out after' + ms + 'ms');
  });
  return Promise.race(promise, timeout);
}

// 使用
const taskPromise = new Promise((resolve) => {
  const delay = Math.random() * 2000;
  setTimeout(() => {
    resolve(delay + 'ms');
  }, delay);
});
timeoutPromise(taskPromise, 1000).then((value) => {
  console.log('规定时间内结束');
}).catch(() => {
  console.log('超时');
});
```

### 2.1 实现一个Promise注意事项
1. 同步任务：利用setTimeout特性将resolve和reject具体执行放到then之后
2. 三种状态：then方法里对三种状态做判断
3. 支持链式操作：then方法里最后返回this
4. 支持串行异步任务：每个回调函数注册在对应的异步操作promise的onFulfilledCallback里。令then最后返回一个新promise




### 2.2 实现Promise.finally?
```js
Promise.prototype.finally = function(callback) {
  let p = this.constructor;
  return this.then(
    value => p.resolve(callback()).then(() => value),
    reason => p.resolve(callback()).then(() => {
      throw reason;
    });
  )
}
```

### 2.3 Promise解决的问题
1. 嵌套问题
2. 控制反转再反转：
* 回调函数执行多次：Promise只能resolve一次
* 回调函数没有执行：用Promise.race解决(超时机制)
* 回调有时同步有时异步：同步异步共存情况无法保证程序逻辑的一致性，而Promise解决了这个问题。

## 3. 异步迭代生成器
```js
let it;

function foo(x, y) {
  ajax('http://xxx', function(err, data) {
    if (err) {
      it.throw(err);
    } else {
      it.next(data);
    }
  });
}

function *main() {
  try {
    // 暂停
    // 请求成功，it.next()
    // 赋给text
    const text = yield foo(11, 31);
    console.log(text);
  } catch(err) {
    ...
  }
}
// 调用
it = main();
it.next();
```
优点：
1. 抽象了异步;
2. 同步形式追踪流程控制;
3. 同步捕获异步错误;

#### 生成器 + Promise
```js
function *main {
  // 同上
}
function foo(x, y) {
  return request('http://url'); // 一个promise
}

// 调用
const it = main();;
const p = it.next().value;
p.then(function(text) {
  it.next();
}, function(err) {
  it.throw(err);
})
```

#### async与await
```js
function foo(x, y) {
  // 一样
}

async function main() {
  try {
    const text = await foo(11, 31);
    console.log(text);
  } catch(err) {
    console.log(err);
  }
}

// 调用
main();
```
#### 举例
2个请求并发，都完成后请求第3个；
```js
function *foo() {
  const p1 = request("http://url1");
  const p2 = request("http://url2");
  const r1 = yield p1;
  const r2 = yield p2;
  const r3 = yield request("http://url3");
  console.log(r3);
}
```
更简化：
```js
function bar(url1, url2) {
  return Promise.all([
    request(url1),
    request(url2)
  ]);
}

function *foo() {
  // 隐藏promise并发细节
  const result = yield bar("http://url1", "http://url2");
  const [r1, r2] = result;
  const r3 = yield request("http://url3");
  console.log(r3);
}
```

#### 兼容
没有生成器的兼容迭代器函数代码
```js
function foo(url) {
  let state;
  let val;
  function process(v) {
    switch(state) {
      case 1:
        console.log(url);
        return request(url); // 一个promise
      case 2:
        val = v;
        return;
      case 3: 
        const err = v;
        return false;
    }
  }
  return {
    next: function(v) {
      if (!state) {
        state = 1;
        return {
          done: false,
          value: process();
        };
      } else if (state === 1) {
        state = 2;
        return {
          done: true,
          vlaue: process()
        };
      } else {
        return {
          done: true,
          value: undefined
        }；
      }
    }，
    "throw": function(e) {
      if (state === 1) {
        state = 3;
        return {
          done: true,
          value: process(),
        }
      } else {
        throw e;
      }
    }
  }
}

// 调用
const it = foo("url");
const p = it.next().value;
p.then(function(text) {
  it.next();
}, function(err) {
  it.throw(err);
});
```