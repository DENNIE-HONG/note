# http等
## 1. get/post
除了http层区别，在tcp/ip层面也有区别  
get请求：
```
headers + data  --->   服务器     
tcp数据包       <--- 200
```

post请求：  
```js
headers  ----->    服务器
tcp包   <------
        100 continue

data     ----->    服务器
tcp包    <----
          200
```

## 2. 双向通信
### 2.1 webSocket
允许服务器主动发送信息给客户端，双向数据流协议
与http是两码事。
* 传统TCP socket：标准化的API
* webSocket: 网络协议  
```js
// 创建WebSocket协议请求
const socket = new WebSocket('ws://127.0.0.1/updates');
// 连接打开，每50ms向服务器端发送一次数据
socket.onopen = function() {
  setInterval(function() {
    if (socket.bufferedAmount === 0) {
      socket.send(getUpdateData());
    }
  }, 50);
}

// 接收服务器端传来的数据
socket.onmessage = function(event) {
  // todo
};
```
websocket握手：通过HTTP发起请求报文
协议头区别：
* Upgrade: websocket
* Connection: Upgrade


### 2.2 轮询
借助于setInterval等方式，客户端不断发送请求并得到相应。但轮询间隔过长，用户收到消息不及时，轮询间隔太短，增加服务器负担。



### 2.3 长轮询
客户端发出请求后，服务端用while(true)等方式阻塞住请求，直到有可用数据发送响应，又称为“comet”、“反向ajax”。但仍然是基于http的一种慢响应。
### 2.4 HTTP流（基于iframe）
```

           connect
          --------------> 
 _______           push      ________
|client | <--------------   | server |
|_______|           push    |________|
          <---------------
          close connection
          ---------------->
```
使用http1.1且响应头中包含Transfer-Encoding:chunked情况下，服务器发送给客户端数据可分成多个部分，保持打开，并周期性flush()分块传输。但数据响应可能会因代理服务器or防火墙等中间人造成延迟。
### 2.5 SSE(Server-Sent-Events)
服务端响应内容类型是text/event-stream,在浏览器端使用EventSource对象处理返回的数据。  
但不支持CORS，单向通信，浏览器兼容性差。

## 3.http1.1与http2

### http1.0
**线头问题**：
http1.0允许通过一个TCP连接发出一个请求，浏览器需等待缓慢的响应后才能再发起另一个。  
协议规定每个主机最多打开2个TCP连接。  
解决：
域分片（多个主机，多个域名）
浏览器供应商违反协议，任意增加开放连接数(chrome: 24)



### http1.1
缺点：  
1. 客户端对同一域请求连接数有限制，不同浏览器有不同规定；
2. 线头阻塞问题：同一连接中的请求，需串行发送接收；
3. 请求和响应头大，无法压缩；
4. 只能单向请求；

### http2
升级：  
* 多路复用
* HPACK头压缩
* 流十二进制帧
* 流优先级等

特性：  
1. 传输内容使用二进制协议（更小的传输体积）
2. 使用帧作为最小传输单位（低延迟）
3. 多路复用（并发，同一流中帧交错传输，先到不一定先返回）
4. 头压缩
5. 服务器推送
6. 优先级与依赖性
7. 可重置
8. 流量控制

#### 多路复用（并发，同一流中帧交错传输，先到不一定先返回）
```js
                  请求/响应帧交织在一起
     ________________________________________________
    |    _________  ________   ________   ________   |
浏  |___/  frame1 |/  frame2 |/ frame2 |_/ frame1 |__|   服
览  |   \ HEADERS |\ HEADERS |\  DATA  | \  DATA  |  |   务
器  |    —————————  —————————  ————————   ————————   |   器
    |                ________   _________            |
    |_______________| frame3 \_| frame3  \___________|
    |               |  DATA  / | HEADERS /           |
    |                ————————   —————————            |
    |________________________________________________| 
                所有帧在另一端重新组装
```


## 4. 缓存
### 强缓存：
HTTP通过缓存将服务器文档的副本保留一段时间，在这段时间内，都认为文档是新鲜的，浏览器返回200状态码（from cache）
### 协商缓存
缓存要再次与服务器验证，已查看文档是否发生了变化，结果3种：
* 命中：发送一个小的HTTP 304 Not Modified响应；
* 未命中：服务器与缓存副本不同，服务器发带有完整内容的HTTP 200 OK；
* 对象被删除：服务器返回404响应，缓存也会删除其副本。



# 5.HTTPS
超文本传输安全协议。经由HTTP进行通信，但利用SSL/TLS来加密数据包，提供对网站服务器的身份认证，保护数据的隐私与完整性。  
**TLS/SSL**: 依赖散列函数、对称加密和非对称加密。  
**TCP**: 传输层控制协议，提供面向连接、可靠的字节流服务。
```js
             _____________          
            | server 私钥 | 
             —————————————  
         ^               ^
    _____|______   ______|_____
   |clientA 公钥|  |clientB公钥 | ...
    ———————————     ———————————

```
若公钥传输中被掉包？  
数据签名 + 证书。  
若没有签名，中间人也向第三方认证机构申请，拦截后把所有信息都替换成自己。

```js
           ______                                               ______
          |client|                                             |server|
           ——————                                               ——————
             |                                                     |
             |           请求公钥                                   |
             |    ———————————————————————————————————————————>     |
             |                                                     |
    —————————————————————————                                      |
   |浏览器会安装带有一些权威第三|       第三方机构加密                    |
   |方机构的公钥，使用相匹配的公|    __________________                 |
   |钥对数字签名进行解密，根据签|   |      数字证书     |                |
   |名生成规则对网站信息进行本地|   | 公钥 + 数字签名   |                 |
   |签名生成，两个签名进行对比，|   |__________________|                |
   |如果对比成功，则公钥是正确的|  <————————————————————————————————    |
    _________________________                                      |
             |                                                     |
             |客户端生成随机对称秘钥                                   |
             |————————————                                         |
             |            |                                        |
             | <——————————                                         |
             | 使用公钥对对称                                        |
             |——————————————                                       |
             |              |秘钥加密                               |
             |<—————————————                                       |
             |                                                     |
             |                                 发送加密后的对称秘钥    |
             |                     ——————————————————————————————> |
             |                                                     |
             |                            通过对称秘钥加密的密文通信    |
             |                      —————————————————————————————> |
             |                                                     |


```


# 6.请求资源
请求静态资源的流程： 
```js
web页面       -------------------------             ____________
  __         |   ________________     |            | 服务器     |
 |  |        |  | 浏览器私有缓存  |     |            |           |
 |  |        |   ————————————————     |            |           |
 |  |GET请求  |        ______          |            |           |
 |  |——————————————> | 查询 |          |            |           |
 |  |        |        ——————          |            |           |
 |  |        |     _____|____         |            |  _____    |
 |  |        |    |新鲜度检查 |———N————————————————————|再验证|   |
 |  |        |     ——————————         |            |  —————    | 
 |  |200(from cache)    |             |            |      |    |     
 |  |<————————————Y—————|             |            |   ___|__  |
 |  |304(not modified)   _________     304         |  |通过? |  |
 |  |<——————————————————|更新新鲜度|<—————————————————Y—|_____|  |
 |  |        |           —————————    |            |      |    |
 |  |        |                        |            |      N    |
 |  | 200    |         _____________  |            |______|___ |
 |  |<————————————————|新内容存入缓存|<——————————Y———|资源是否存在| |
 |  |        |         —————————————  |            |—————————— |
 |  |        |                        |            |      |    |
 |  |404(not found)      __________   |            |      N    |
 |  |<——————————————————| 删除缓存  |<———————————————————— |    |
 |  |        |           ——————————   |            |           |
 |  |        |                        |            |           |
  ——         |                        |             ———————————
              ------------------------
```
### ETag
是服务器响应请求时，返回当前资源文件的一个唯一标识。
### If-None-Match
是客服端再次发起请求时，携带上次请求返回的唯一标识Etag值。服务器收到请求，根据If-None-Match字段与Etag对比，结果；
* 一致：返回304，资源无更新；
* 不一致，重新返回资源文件，状态码200
