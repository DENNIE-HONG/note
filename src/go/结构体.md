# 结构体

## 名称
包名总是小写的，实体名第一个字母大小写决定是否跨包。
Go的编程风格倾向使用短名称，特别是作用范围比较小的局部变量。

### 关键字
和js不同的的：
**select**
**struct**
**fallthrough**
**range**
**chan**
**go**
**goto**

### 常量
iota
iota 是 Go 语言中用于简化常量声明的‌预声明标识符‌，本质是 const 代码块中的‌行计数器‌（从 0 开始按行自增）

例如：
简化枚举值定义，避免手动赋值23：
```go
const (
    StatePending = iota // 0
    StateSuccess        // 1
    StateFailed         // 2
)
```

### 函数
**panic**
panic 用于主动抛出运行时异常，中断当前函数的执行，并逐层向上执行 defer 语句，最终终止程序或由 recover 捕获

**recover**
1. ‌使用条件‌

必须在 defer 函数中调用 recover 才能生效.
仅能捕获‌当前协程‌内的 panic，无法跨协程处理.
2. ‌恢复逻辑‌
捕获 panic 后返回其传递的参数，程序从 defer 之后的代码继续执行（而非 panic 发生点）
若未发生 panic，recover 返回 nil

```go
func safeCall() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println("Recovered:", err) // 捕获并处理 panic
        }
    }()
    panic("manual panic") // 触发 panic
}

```

**real**
函数用于提取复数的‌实部‌（实数部分），返回值为 float64 类型
```go
c := complex(3.5, 2.1) // 创建复数 3.5 + 2.1i
r := real(c)           // 提取实部 3.5
fmt.Println(r)         // 输出: 3.5

```

**make**
Go 语言中的 make 函数是用于初始化‌引用类型‌（切片、映射、通道）的内置函数，其核心特性和用法如下：

```go
m := make(map[string]int, 100)  // 初始容量100的空映射

```

## 变量
**var name type = expresion**
```go
var i, j, k int // int int int
```

### 短变量声明
**name:= expression**
短变量声明不需要声明所有在左边的变量，最少声明一个变量。

```go
f, err := os.Open(infile)
//...
f, err := os.Create(outfile) // 编译报错：没有新的变量
```

### 指针
var x int
&x：获取一个指向整型变量的指针
指针对于flag包很关键，使用程序的命令行参数来设置整个程序内某些变量的值。

```go
package main

import (
	"flag"
	"fmt"
	"strings"
)

var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

func main() {
    // 必须更新标识的默认值
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}
```

## 赋值
### 多重赋值
函数通常使用额外的返回值来来指示一些错误的情况。
```go
v, ok = map[k] // map查询
v, ok = x.[T]  // 类型断言
```
## 类型声明
**type name underling-type**
类型转换
T(x) 将x转换为T, 2个类型具有相同的底层类型是可以互相转换的。
