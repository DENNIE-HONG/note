# 使用共享变量实现并发
## 竞态
**并发安全**函数在并发调用时仍然能正确工作。**竞态**是指在多个goroutine按某些交错顺序执行程序无法给出正确的结果。
例子：竞态的严重性带来的经济损失

```go
//
package bank

var balance int
func Desposit(amount int) {blance = blance + amount}
func Balance() int {
    return balance
}
// Alice
go func() {
    bank.Deposit(200) // A1
    fmt.Println("=", bank.Balance()) // A2
}()
// Bob:
go bank.Deposit(100)
```
我们无法预测实际的执行顺序。A1的操作实际是串行的2个操作，读部分和写部分，如果先B，后A1写，B的100元会被忽略，称为**数据竞态**，data race发生与两个goroutine并发读写同一个变量并且至少其中一个是写入时。
如何在程序中避免数据竞态呢？
1. 不要修改变量。比如用完整的数据来初始化变量，那些从不修改的数据结构以及不可变数据结构本质上是并发安全的。
2. 避免多个goroutine访问同一个变量。比如，并发的Web爬虫中主goroutine是唯一一个能访问seen map的goroutine；*不要通过共享内存来通信，而是应该通过通信来共享内存*。**变量的监控**：指的是一个goroutine, 使用通道访问受限变量。
3. 同一个变量，同一时间只有一个goroutine访问,即**互斥机制**。
重写银行的案例，用一个叫teller的监控goroutine限制balance变量：

```go
var deposits = make(chan int) // send amount to deposit
var balances = make(chan int) // receive balance

func Deposit(amount int) { deposits <- amount }
func Balance() int       { return <-balances }

func teller() {
	var balance int // balance is confined to teller goroutine
	for {
		select {
		case amount := <-deposits:
			balance += amount
		case balances <- balance:
		}
	}
}

func init() {
	go teller() // start the monitor goroutine
}
```
## 互斥锁 sync.Mutex
理论上可以使用一个容量为1的通道来保证同一个时间最多只有1个goroutine访问共享变量。一个计数上限为1的信号量称为*二进制信号量*。
```go
var (
	sema    = make(chan struct{}, 1) // 用来保护balance的二进制信号量
	balance int
)

func Deposit(amount int) {
	sema <- struct{}{} // 获取令牌
	balance = balance + amount
	<-sema // 释放令牌
}

func Balance() int {
	sema <- struct{}{} // acquire token
	b := balance
	<-sema // release token
	return b
}
```
sync包有单独的**Mutex类型**来支持互斥锁模式，Lock = 获取令牌（上锁），Unlock=释放令牌。
```go
import "sync"

var (
	mu      sync.Mutex // guards balance
	balance int // 按照惯例，被保护的变量声明紧接在互斥量声明之后
)

func Deposit(amount int) {
	mu.Lock()
	balance = balance + amount // 这个区域是临界区域
	mu.Unlock()
}

func Balance() int {
	mu.Lock()
	b := balance
	mu.Unlock()
	return b
}

```
```go
// 为了确保所有分支都执行了lock和unlock，可以用defer
func Balance() int {
	mu.Lock()
	defer mu.Unlock()
	return balance
}
```
注意：Go语言的互斥量是不可再入的（无法对一个已经上锁的互斥量再上锁），否则会导致**死锁**。

## 读写互斥锁：sync.RWMutex
如果Balace函数值读取变量的状态，多个Balance请求其实可以安全并发，有一种特殊的锁，允许只读操作可以并发执行，但写操作需要获取完全独享的访问权限。这种锁称为**多读单写锁**。
```go
var mu sync.RWMutex
var balance int
func Balance() int {
    mu.RLock() // 读锁
    defer mu.RUnlock()
    return balance
}
```
但是在竞争不激烈时，多读单写锁比普通的互斥锁慢。

## 内存同步
为什么一个读区变量的方法也需要互斥锁？毕竟它只包含单个操作，并不存在另外一个goroutine插在中间执行的风险？
因为：
1. 防止Balance插到其他操作中间也很重要
2. 同步不仅涉及多个goroutine的执行顺序，还会影响内存；
现代计算机多处理器，在刷回内存的顺序可能与goroutine的写入顺序不一样。
例子：
```go
var x, y int
go func() {
    x = 1
    fmt.Print("y:", y, " ")
}()
go func() {
    y =1
    fmt.Print("x:", x, " ")
}
```
可能输出x:0 y:0
理论上单个goroutine内，是串行一致的，但是没有通道或者使用互斥锁，并不能保证所有的goroutine编译或事件顺序是一致的。现在编译器和CPU可能认为赋值和Print的执行顺序不影响结果，然后就交换了这2个语句的执行顺序。

## 延迟初始化：sync.Once
优化，变量的初始化延迟到实际需要时候。但是并发调用延迟的变量是不安全的。（关于并发的直觉都不可靠）
编译器和CPU能保证每个goroutine都满足串行一致性的基础上自由重排访问内存的顺序。
例如：
```go
var icons map[string]image.Image
func loadIcons() {
    icons = map[string]image.Image{
        "xxx":  loadIcon("spades.png"),
        ...
    }
}
// 并发不安全
func Icon(name string) image.Image {
    if icons == nil {
        loadIcons() // 一次性初始化
    }
    return icons[name]
}
```

可能重排会先把一个空map赋给变量icons，优化：先获取一个读锁，查阅map，释放读锁。如果有找到就返回，没有goroutine再获取一个写锁。sync包提供了一次性初始化的方案：sync.Once.

```go
var loadIconsOnce sync.Once
var icons map[string]image.Image

// 并发安全
func Icon(name string) image.Image {
    loadIconsOnce.Do(loadIcons)
    return icons[name]
}
```

## 示例：并发非阻塞缓存
httpGetBody函数缓存结果问题，请求一个url，缓存结果，第一次才计算，后面就用缓存。
要求：并发也要安全，避免对整个缓存使用单锁导致的锁争夺。

```go
type Memo struct {
	f     Func
	cache map[string]result
}
...
func New(f Func) *Memo {
	return &Memo{f: f, cache: make(map[string]result)}
}

// 并发不安全
func (memo *Memo) Get(key string) (interface{}, error) {
	res, ok := memo.cache[key]
	if !ok {
		res.value, res.err = memo.f(key)
        // 存在数据竞争
		memo.cache[key] = res
	}
	return res.value, res.err
}

```
第一版优化：给Memo加一个互斥量，直接在函数开头加锁，返回前释放锁
```go
type Memo struct {
	f     Func
	mu    sync.Mutex // guards cache
	cache map[string]result
}
...
func (memo *Memo) Get(key string) (value interface{}, err error) {
	memo.mu.Lock()
	res, ok := memo.cache[key]
	if !ok {
        // 每次调用f都上锁，串行了，没并行了
		res.value, res.err = memo.f(key)
		memo.cache[key] = res
	}
	memo.mu.Unlock()
	return res.value, res.err
}
```
第二次优化：要**非阻塞的缓存**，第一个查询用锁，第二次在结果更新时候用锁
```go
func (memo *Memo) Get(key string) (value interface{}, err error) {
	memo.mu.Lock()
	res, ok := memo.cache[key]
	memo.mu.Unlock()
	if !ok {
		res.value, res.err = memo.f(key)

		// 在2个临界区域之前，可能有多个goroutine来计算f
        // 更新map
		memo.mu.Lock()
		memo.cache[key] = res
		memo.mu.Unlock()
	}
	return res.value, res.err
}
```
第三次优化：**重复抑制**，重复并行查一个url，避免2个goroutine都去查缓存了，又去执行函数。利用一个entry结构的指针，额外增加通道ready，result有结果后，通道关闭，让正在等待的goroutine收到广播，直接从entry读取结果。

```go
type entry struct {
	res   result
	ready chan struct{} // closed when res is ready
}
type Memo struct {
	f     Func
	mu    sync.Mutex // guards cache
	cache map[string]*entry
}
func (memo *Memo) Get(key string) (value interface{}, err error) {
	memo.mu.Lock()
	e := memo.cache[key]
	if e == nil {
		// 第一次访问，计算数据和广播数据.
		// 准备完毕的消息
		e = &entry{ready: make(chan struct{})}
		memo.cache[key] = e
		memo.mu.Unlock()

		e.res.value, e.res.err = memo.f(key)

		close(e.ready) // 广播数据已准备完毕的消息
	} else {
		// 第二次访问
		memo.mu.Unlock()

		<-e.ready // 等数据准备完毕
	}
	return e.res.value, e.res.err
}
```



## goroutine与线程
如何区分goroutine和线程
### 可增长的栈
1. OS线程都有一个固定大小的栈内存（通常为2MB）
2. 一个goroutine在生命周期开始只有一个很小的栈，典型情况下是2kb，不是固定大小，可以按需增大和缩小。

### goroutine调度
1. OS线程由OS内核调度，每隔x毫秒，中断发送到CPU, CPU调度一个调度器暂停当前运行的线程，寄存器信息保存到内存。查看线程列表并决定下一个运行哪个，其中需要一个完整的上下文切换，这一些系列的操作是很慢的。
2. Go调度器是由特定的Go语言触发，比如time.Sleep或者互斥操作等，调度器就会将这个goroutine设为休眠模式，并运行其他goroutine直到前一个可重新唤醒为止。不需要切换到内核语境，成本低。

### GOMAXPROCS
Go调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行GO代码，默认是CPU数量。可以用环境变量显式控制这个参数。
```go
for {
    go fmt.Print(0)
    fmt.Print(1)
}
// GOMAXPROCS=1 go run test.go
// 111111111111111000000000000000001111111...
// 先主goroutine，主休眠，唤醒另一个goroutine输出0
```
### goroutine没有标识
线程局部储存有滥用的倾向。Go语言鼓励一种更简单的编程风格，能影响一个函数行为的参数应当是显式指定的。
