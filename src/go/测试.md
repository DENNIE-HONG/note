# 测试

## go test工具
go test命令执行*_test.go文件，文件中有三种函数：
* 功能测试函数： Test前缀命名，返回PASS OR FAIL
* 基准测试函数: Benchmark开头，汇报平均执行时间
* 示例函数: Example开头，提供机器检查过的文档

## Test函数
测试文件要导入testing包，签名函数如下：

```go
func TestName (t * testing T) {
    var tests = []struct {
        input string
        want bool
    }{
        {"", true},
        ...
    }
    for _, test := range test {
        if got := xxx(test.input); got != test.want {
            t.Errorf("xxx")
        }
    }
}
```
这种基于表的测试方式比较常见，一个条目造成测试失败，不会中断，可以在一次测试中发现多个失败case。测试错误消息一般格式是“f(x) = y ,want z"

### 随机测试
另外一种方式是随机测试，通过随机构建输入来扩展测试覆盖范围。可以构建某种符合模式的输入。

### 测试命令
例如已经有一个echo.go, 包名是main，echo_test.go中：
```go
func TestEcho(t *testing.T) {
    var tests = []struct {
        newline bool
        sep     string
        args    string[]
        want    string
    }{
        {true,"",[]string{}, "\n"}
        ...
    }
    for _, test := range tests {
        if err := echo(tst.newline,test.sep, test.args); err!= nil {
            t.Errorf("%s failed: %v", descr,err)
        }
        ...
    }
}
```
测试代码和代码在一个包里，包名叫main，在测试过程中，这个包当作库来测试，main函数则被忽略了。

### 白盒测试
**黑盒测试**：假设测试者对包的了解仅通过公开的API和文档，而包的内部逻辑是不透明的。
**百盒测试**：可以访问包的内部函数和数据结构，做一些用户无法做到的观察和改动。

### 外部测试包
比如net/url, 高级的net/http包依赖低级的net/url, 在net/url包中一个测试是用来演示URL和http库之间进行交互的例子，即低级包的测试导入了高级包。理论上，这个测试函数会导致*包循环引用*。
怎么办？
解决：测试函数定义在外部测试包中。在net/url中，有一个包声明是url_test,这个外部测试包导入路径是net/url_test。
外部测试包允许测试用例，尤其是**集成测试**，自由导入其他的包，就像一个应用程序那样。
go list可以看出哪些是包内测试、外部测试。
go list -f={{.GOFiles}} fmt
go list -f={{.TestGoFiles}} fmt
go list -f={{.XTestGoFiles}} fmt
包内测试可以添加函数声明，将包内功能暴露给外部测试，它们一般称为export_test.go

## 覆盖率
一个测试套件覆盖待测试包的比例。覆盖率无法直接通过数量来衡量，任何事情都是动态的。
**语句覆盖率**是一种最简单且广泛的使用方法。部分语句在一次执行中至少执行一次。cover工具，用来衡量语句覆盖率。
go test -run=Coverage -coverprofile=c.out xxx
go test -convermode=count：
可以识别执行频率较高的“热块”或者相反的“冷块”。
利用go tool cover -html=c.out
绿色标记表示被覆盖，红色没有被覆盖。

## Benchmark函数
基准测试在一定的工作负载之下检测程序性能的一种方法。测试函数前缀Benchmark,提供一个整型成员N,用来指定被检测操作的执行次数。
```go
import "test"

func BenchmarkIsPalindrome(b *testing.B) {
    for i := 0; i < b.N; i++ {
        IsPalindrome("A man, a plan, a cancal: Panama")
    }
}
```
*-bench*指定要运行的基准测试
go test -bench=.
PASS
BenchmarkIsPalindrome-8 1000000     1035 ns/op
ok    xxx       2.179s
8表示GOMAXPROCS,并发基准测试很重要。
调用1000000次，平均耗时1035ns

*-benchmem*： 报告中包含内存分配统计数据。

## 性能剖析
*我们必须忘记微小的性能提升，在97%的情况下，过早优化是万恶之源。当然不可以错误那关键的3%的情况。*
发现关键代码的最佳技术就是**性能剖析**(profile)。性能剖析是通过自动化手段在程序执行过程中基于一些性能事件的采样来进行性能评测，然后再从这些采样中推断分析，得到统计报告.
有多种性能剖析方式：
* CPU性能剖析：识别出执行过程中需要CPU最多的函数。
* 堆性能剖析：识别分配最多内存的语句。
* 阻塞性能剖析：识别阻塞协程最久的操作，例如通道发送和接收，以及获取锁等。
go test -cpuprofile=cpu.out
go test -blockprofile=block.out
go test -memprofile=mem.out
用go tool pprof工具类分析性能剖析结果。


## Example函数
名字以Example开头，没有参数也没结果，示例函数的目的：
1. 作为文档，描述库函数最简洁直观的方式。
2. 可以通过go test运行，如果示例函数最后包含一个注释 // 输出：，执行函数并检出输出到终端的内容匹配这个注释的文本。
3. 提供手动实验代码，例如在golang.org的godoc文档服务器使用Go Playground来让用户在Web浏览器上编辑和运行每个示例函数，这个通常是了解特定函数功能最快捷的方法。
